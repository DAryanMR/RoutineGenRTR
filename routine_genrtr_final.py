# -*- coding: utf-8 -*-
"""routine_genRTR_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MOxB-55pSFCqRKrIUTpfybIc-FQOu8UF

# Default__System__
"""

# @title Setup__base__routine__: Database
base_routine = {
    "1A": [[[("MED", "10:00-11:30")], [("PF", "11:30-13:00")], [("DIC", "13:30-15:00")]],
           [[("GE", "10:00-11:30")], [("IEE", "11:30-13:00")]],
           [[("PF", "10:00-11:30")], [("PFL", "11:30-14:30")],
            [("IEEL", "14:30-17:30")]],
           [[("IEE", "10:00-11:30")], [("ICMP", "11:30-13:00")],
            [("DIC", "13:00-15:00")]],
           [[("CFE", "8:30-11:30")], [("GE", "11:30-13:00")],
            [("ICMP", "13:00-14:30")]],
           ],
    "1B": [[[("PF", "10:00-11:30")], [("MED", "11:30-13:00")], [("IEE", "13:00-14:30")], [("DIC", "15:00-16:30")]],
           [[("PF", "10:00-11:30")], [("PFL", "11:30-14:30")]],
           [[("GE", "8:30-10:00")], [("IEEL", "11:30-14:30")]],
           [[("CFE", "8:30-11:30")], [("IEE", "11:30-13:00")],
            [("ICMP", "13:00-14:30")], [("DIC", "15:00-16:30")]],
           [[("GE", "10:00-11:30")], [("ICMP", "11:30-13:00")]],
           ],
    "1C": [[[("MED", "8:30-10:00")], [("CFE", "10:00-13:00")], [("PF", "13:30-15:00")], [("DIC", "15:00-16:30")]],
           [[("GE", "13:00-14:30")], [("IEEL", "14:30-17:30")]],
           [[("ICMP", "10:00-11:30")], [("IEE", "11:30-13:00")]],
           [[("ICMP", "8:30-10:00")], [("GE", "10:00-11:30")],
            [("IEE", "11:30-13:00")], [("DIC", "14:00-15:30")]],
           [[("PF", "10:00-11:30")], [("PFL", "11:30-14:30")]],
           ],
    "1D": [[[("ICMP", "10:00-11:30")], [("MED", "11:30-13:00")], [("DIC", "13:30-15:00")]],
           [[("GE", "8:30-10:00")], [("PF", "10:00-11:30")],
            [("IEE", "11:30-13:00")]],
           [[("CFE", "8:30-11:30")], [("PF", "11:30-13:00")]],
           [[("ICMP", "10:00-11:30")], [("PFL", "11:30-13:00")],
            [("DIC", "15:30-17:00")]],
           [[("IEE", "11:30-13:00")], [("GE", "13:00-14:30")],
            [("IEEL", "14:30-17:30")]],
           ],
    "1E": [[[("ICMP", "8:30-10:00")], [("MED", "10:00-11:30")], [("DIC", "11:30-13:00")], [("IEE", "13:00-14:30")]],
           [[("CFE", "8:30-11:30")], [("PF", "11:30-13:00")],
            [("GE", "14:30-16:00")]],
           [[("ICMP", "8:30-10:00")], [("PF", "10:00-11:30")],
            [("IEE", "13:00-14:30")]],
           [[("IEEL", "8:30-11:30")], [("GE", "11:30-13:00")]],
           [[("PFL", "8:30-11:30")], [("DIC", "11:30-13:00")]],
           ],
    "2A": [[[("SP", "9:30-11:30")], [("Elec-1L", "11:30-14:30")]],
           [[("EM-2", "10:00-11:30")], [("DM", "11:30-13:00")],
            [("EP-2", "13:00-14:30")]],
           [[("EM-2", "10:00-11:30")], [("DM", "11:30-13:00")]],
           [[("SPL", "9:30-11:30")], [("Elec-1", "13:00-14:30")]],
           [[("EP-2", "10:00-11:30")], [("Elec-1", "11:30-13:00")],
            [("DES", "14:30-16:30")]],
           ],
    "2B": [[[("Elec-1L", "8:30-11:30")], [("EP-2", "11:30-13:00")], [("DM", "13:00-14:30")], [("SPL", "14:30-16:30")]],
           [[("EM-2", "11:30-13:00")], [("SPL", "14:30-16:30")]],
           [[("Elec-1", "8:30-10:00")], [("DES", "10:30-12:30")]],
           [[("EM-2", "13:00-14:30")], [("EP-2", "14:30-16:00")]],
           [[("SP", "9:30-11:30")], [("DM", "13:00-14:30")],
            [("Elec-1", "15:00-16:30")]],
           ],
    "2C": [[[("DM", "10:00-11:30")], [("EM-2", "11:30-13:00")], [("EP-2", "13:00-14:30")]],
           [[("EP-2", "11:30-13:00")]],
           [[("Elec-1", "10:00-11:30")], [("DES", "12:30-14:30")]],
           [[("EM-2", "10:00-11:30")], [("SP", "11:30-13:00")]],
           [[("DM", "11:30-13:00")], [("Elec-1", "13:30-15:00")]],
           ],
    "2C1": [[[(), ()]],
            [[("SPL", "9:30-11:30")]],
            [[(), ()]],
            [[("SPL", "14:30-16:30")]],
            [[("Elec-1L", "8:30-11:30")]],
            ],
    "2C2": [[[("SPL", "14:30-16:30")]],
            [[("SPL", "14:30-16:30")]],
            [[(), ()]],
            [[("Elec-1L", "14:30-17:30")]],
            [[(), ()]],
            ],

    "3A": [[[("DE", "8:30-10:00")], [("EM-3", "10:00-11:30")], [("OOPL", "11:30-14:30")]],
           [[("DS", "13:00-14:30")], [("BE", "16:00-17:30")]],
           [[("DSL", "8:30-11:30")], [("OOP", "13:00-14:30")]],
           [[("OOP", "10:00-11:30")], [("EM-3", "11:30-13:00")],
            [("DS", "13:00-14:30")]],
           [[("DE", "8:30-10:00")], [("DEL", "11:30-14:30")],
            [("BE", "14:30-16:00")]],
           ],
    "3B": [[[("DE", "10:00-11:30")], [("EM-3", "13:00-14:30")]],
           [[("DS", "10:00-11:30")], [("OOPL", "11:30-14:30")],
            [("BE", "14:30-16:00")]],
           [[("DEL", "8:30-11:30")], [("OOP", "11:30-13:00")],
            [("EM-3", "13:00-14:30")]],
           [[("DS", "10:00-11:30")], [("OOP", "11:30-13:00")]],
           [[("DE", "10:00-11:30")], [("DSL", "11:30-14:30")],
            [("BE", "16:00-17:30")]],
           ],
    "3C": [[[("DS", "8:30-10:00")], [("DE", "10:00-11:30")], [("OOP", "13:00-14:30")]],
           [[("OOP", "10:00-11:30")], [("BE", "14:30-16:00")]],
           [[("EM-3", "11:30-13:00")]],
           [[("DS", "8:30-10:00")]],
           [[("EM-3", "10:00-11:30")], [("DE", "14:30-16:00")],
            [("BE", "16:00-17:30")]],
           ],
    "3C1": [[[(), ()]],
            [[("DEL", "11:30-14:30")]],
            [[("OOPL", "14:30-17:30")]],
            [[(), ()]],
            [[("DSL", "11:30-14:30")]],
            ],
    "3C2": [[[(), ()]],
            [[("DSL", "11:30-14:30")]],
            [[("OOPL", "8:30-11:30")]],  #
            [[("DEL", "11:30-14:30")]],
            [[(), ()]],
            ],
    "3D": [[[("DS", "10:00-11:30")], [("DE", "11:30-13:00")]],
           [[("EM-3", "13:00-14:30")], [("BE", "16:00-17:30")]],
           [[("OOP", "10:00-11:30")]],
           [[("OOP", "8:30-10:00")], [("DS", "10:00-11:30")]],
           [[("EM-3", "13:00-14:30")], [("BE", "14:30-16:00")],
            [("DE", "16:00-17:30")]],
           ],
    "3D1": [[[(), ()]],
            [[("DEL", "8:30-11:30")]],
            [[("OOPL", "11:30-14:30")], [("DSL", "14:30-17:30")]],
            [[(), ()]],
            [[(), ()]],
            ],
    "3D2": [[[("DEL", "14:30-17:30")]],
            [[(), ()]],
            [[("DSL", "11:30-14:30")], [("OOPL", "14:30-17:30")]],
            [[(), ()]],
            [[(), ()]],
            ],

    "4A": [[[("DMS", "11:30-13:00")], [("ADA", "11:30-14:30")]],
           [[("IBM", "10:00-11:30")], [("EM-4", "13:00-14:30")]],
           [[("ADA", "10:00-11:30")], [("SS", "11:30-13:00")]],
           [[("IBM", "10:00-11:30")], [("EM-4", "11:30-13:00")]],
           [[("SS", "11:30-13:00")], [("DMS", "13:00-14:30")]],
           ],
    "4A1": [[[("DMSL", "8:30-11:30")]],
            [[(), ()]],
            [[(), ()]],
            [[(), ()]],
            [[("ADAL", "9:30-11:30")], [("SSL", "14:30-16:30")]],
            ],
    "4A2": [[[("ADAL", "9:30-11:30")]],
            [[(), ()]],
            [[(), ()]],
            [[("SSL", "14:30-17:30")]],
            [[("DMSL", "8:30-11:30")]],
            ],

    "5A": [[[("OB", "10:00-11:30")]],
           [[("MM", "10:00-11:30")], [("CMEP", "11:30-13:00")],
            [("SEISD", "13:00-14:00")]],
           [[("OB", "10:00-11:30")], [("SEISD", "11:30-13:00")],
            [("CMEP", "13:00-14:30")]],
           [[("MM", "11:30-13:00")], [("CE", "13:00-14:30")]],
           [[("CE", "11:30-13:00")], [("SEISD", "13:00-14:30")]],
           ],
    "5A1": [[[("MML", "11:30-14:30")]],
            [[("SEISDL", "14:30-17:30")]],
            [[(), ()]],
            [[("CMEPL", "9:30-11:30")]],
            [[("CEL", "8:30-11:30")]],
            ],
    "5A2": [[[("CEL", "11:30-14:30")]],
            [[("MML", "14:30-17:30")]],
            [[(), ()]],
            [[(), ()]],
            [[("CMEPL", "9:30-11:30")], [("SEISDL", "14:30-17:30")]],
            ],

    "6A": [[[("AI", "10:00-11:30")]],
           [[("AI", "10:00-11:30")], [("OS", "11:30-13:00")],
            [("CN", "13:00-14:30")]],
           [[("COA", "11:30-13:00")], [("OS", "13:00-14:30")]],
           [[("CN", "10:00-11:30")], [("DC", "11:30-13:00")]],
           [[("DC", "10:00-11:30")], [("COA", "14:30-16:00")]],
           ],
    "6A1": [[[("CNL", "11:30-14:30")]],
            [[("AIL", "14:30-17:30")]],
            [[(), ()]],
            [[("SD", "14:30-17:30")]],
            [[("OSL", "11:30-14:30")]],
            ],
    "6A2": [[[("SD", "11:30-14:30")]],
            [[("OSL", "14:30-17:30")]],
            [[(), ()]],
            [[("AIL", "14:30-17:30")]],
            [[("CNL", "11:30-14:30")]],
            ],
    "6B": [[[("COA", "10:00-11:30")], [("AI", "11:30-13:00")], [("OS", "13:00-14:30")]],
           [[("CN", "10:00-11:30")], [("OS", "11:30-13:00")],
            [("CN", "13:00-14:30")]],
           [[("CN", "10:00-11:30")], [("DC", "14:30-16:00")]],
           [[("AI", "10:00-11:30")], [("DC", "14:30-16:00")]],
           [[("COA", "11:30-13:00")], [("OS", "13:00-14:30")]],
           ],
    "6B1": [[[(), ()]],
            [[("SD", "11:30-14:30")]],
            [[("AIL", "11:30-14:30")]],
            [[("CNL", "11:30-14:30")]],
            [[("OSL", "14:30-17:30")]],
            ],
    "6B2": [[[(), ()]],
            [[("OSL", "11:30-14:30")]],
            [[("CNL", "11:30-14:30")]],
            [[("SD", "11:30-14:30")]],
            [[("AIL", "14:30-17:30")]],
            ],
    "6C": [[[("CN", "10:00-11:30")], [("OS", "11:30-13:00")]],
           [[("CN", "10:00-11:30")], [("COA", "11:30-13:00")],
            [("AI", "13:00-14:30")]],
           [[("OS", "10:00-11:30")], [("SD", "11:30-14:30")],
            [("AI", "14:30-16:00")], [("DC", "16:00-17:30")]],
           [[("AIL", "8:30-11:30")], [("OSL", "11:30-14:30")],
            [("DC", "16:00-17:30")]],
           [[("COA", "10:00-11:30")], [("CNL", "11:30-14:30")]],
           ],

    "7A": [[[("CGIP", "8:30-10:00")], [("CS", "10:00-11:30")], [("NNFL", "11:30-13:00")], [("TC", "13:00-15:00")]],
           [[("NNFL", "10:00-11:30")]],
           [[("NCS", "11:30-13:00")]],
           [[("NCS", "10:00-11:30")]],
           [[("CGIP", "12:00-13:30")], [("TWP", "13:30-15:30")],
            [("CS", "16:00-17:30")]],
           ],
    "7A1": [[[(), ()]],
            [[(), ()]],
            [[("NNFLL", "10:00-11:30")]],
            [[("CSL", "11:30-14:30")]],
            [[("CGIPL", "10:00-11:30")]],
            ],
    "7A2": [[[(), ()]],
            [[("CSL", "11:30-14:30")]],
            [[("CGIPL", "10:00-11:30")]],
            [[(), ()]],
            [[("NNFLL", "10:00-11:30")]],
            ],
    "7B": [[[("CGIP", "10:00-11:30")], [("CS", "11:30-13:00")]],
           [[("NCS", "11:30-13:00")], [("NNFL", "11:30-14:30")]],
           [[("NNFL", "13:00-14:30")]],
           [[("NCS", "13:00-14:30")]],
           [[("TWP", "8:30-10:30")], [("CGIP", "10:30-12:30")],
            [("TC", "12:30-14:30")], [("CS", "14:30-16:00")]],
           ],
    "7B1": [[[("NNFLL", "13:00-14:30")]],
            [[(), ()]],
            [[("CGIPL", "14:30-16:00")]],
            [[("CSL", "8:30-11:30")]],
            [[(), ()]],
            ],
    "7B2": [[[("CGIPL", "13:00-14:30")]],
            [[(), ()]],
            [[("NNFLL", "14:30-16:00")]],
            [[("CSL", "14:30-17:30")]],
            [[(), ()]],
            ],
    "7C": [[[("CGIP", "11:30-13:00")]],
           [[("CS", "11:30-13:00")], [("NCS", "13:00-14:30")]],
           [[("NNFL", "10:00-11:30")], [("NCS", "13:00-14:30")]],
           [[("CS", "10:00-11:30")], [("NNFL", "11:30-13:00")],
            [("TC", "13:00-14:30")]],
           [[("CGIP", "8:30-10:00")], [("TWP", "10:30-12:30")]],
           ],
    "7C1": [[[("CGIPL", "14:30-16:00")]],
            [[("NNFLL", "10:00-11:30")]],
            [[("CSL", "14:30-17:30")]],
            [[(), ()]],
            [[(), ()]],
            ],
    "7C2": [[[("NNFLL", "10:00-11:30")], [("CSL", "14:30-17:30")]],
            [[("CGIPL", "10:00-11:30")]],
            [[(), ()]],
            [[(), ()]],
            [[(), ()]],
            ],
}

#@title Functions
'''
Necessary functions to sort courses using time_steps
'''


def Sort(sub_li):
    sub_li.sort(key=lambda x: x[1])
    return sub_li


def R_sort(sub_li):
    sub_li.sort(key=lambda x: x[0])
    return sub_li


'''
Function that counts overlap time
'''


def CalculateOverlapTime(t1, t2):
    hour1, minute1 = int(t1.split(':')[0]), int(t1.split(':')[1])
    hour2, minute2 = int(t2.split(':')[0]), int(t2.split(':')[1])
    min1, min2, min3 = 0, 0, 0
    for hrs in range(hour1, hour2+1):
        for mins in range(0, 60):
            if hour1 == hour2 and minute1 == minute2:
                minutes = 0
            elif mins >= minute1 and hrs == hour1:
                min1 += 1
            elif hour1 < hrs < hour2:
                min2 += 1
            elif mins < minute2 and hrs == hour2:
                min3 += 1
    minutes = min1 + min2 + min3
    return (minutes)

'''
Function to calculate available time-slots of a day
'''


def CalculateFreeTimeDay(l):
    time_range = []
    start_val, end_val = 830, 1730
    start_time, end_time = start_val, end_val
    # [i such that i belongs to length of courses] i.e 0->1->2->.. etc..
    for i in range(len(l)):
        course_start, course_end = l[i][0], l[i][1]
        # for all classes except for the last class
        if not course_end == end_val and i < len(l) - 1:
            # if that course has no-free-time before
            if course_start == start_time:
                start_time = course_end
            # if that course has free-time before
            elif course_start > start_time:
                checkpoint1, checkpoint2 = start_time, course_start
                time_range.append([checkpoint1, checkpoint2])
                start_time = course_end
            # handling duplicates
            elif i > 0 and course_start <= l[i-1][0] or course_end <= l[i-1][1]:
                start_time = l[i-1][1]
        # for last class or only class
        elif i == len(l) - 1:
            # if that course has no-free-time before & doesn't end at 17:30
            if course_start == start_time and course_end != end_time:
                checkpoint1, checkpoint2 = course_end, end_time
                time_range.append([checkpoint1, checkpoint2])
            # if that course has free-time before
            elif course_start > start_time:
                checkpoint1, checkpoint2 = start_time, course_start
                time_range.append([checkpoint1, checkpoint2])
                # & doesn't end at 17:30
                if course_end != end_time:
                    checkpoint3, checkpoint4 = course_end, end_time
                    time_range.append([checkpoint3, checkpoint4])
            # handling duplicates
            elif i > 0 and course_start <= l[i-1][0] or course_end <= l[i-1][1]:
                checkpoint1, checkpoint2 = l[i-1][1], end_time
                time_range.append([checkpoint1, checkpoint2])
            elif start_time > course_start and course_end != end_time:
                checkpoint1, checkpoint2 = course_end, end_time
                time_range.append([checkpoint1, checkpoint2])
    R_sort(time_range)
    return (time_range)


'''
extending that to calculate free-time-slots of the whole week
'''
test_results = {
    'Sat': [],
    'Sun': [],
    'Mon': [],
    'Tue': [],
    'Wed': []
}


def CalculateFreeTimeWeek(week):
    for day, times in week.items():
        test_results[day] = CalculateFreeTimeDay(times)
        # print(f'{day}:', test_results[day])


def rem__ov__crs(routine, ov_crs_list, comp_list_, fn_time_list_):
    for day, val in routine.items():
        removing_crs_ = []
        for i in range(len(val)):
            curr_slot_, curr_crs_ = val[i], val[i][0]
            for j in range(len(ov_crs_list)):
                if curr_crs_ == ov_crs_list[j][0]:
                    removing_crs_.append(curr_slot_)
        for slots in removing_crs_:
            for k in range(len(routine[day])):
                if routine[day][k] == slots:
                    fr_rmv_ = routine[day][k]
                    cl_rmv_ = comp_list_[day][k]
                    ftl_rmv_ = fn_time_list_[day][k]
            routine[day].remove(fr_rmv_)
            comp_list_[day].remove(cl_rmv_)
            fn_time_list_[day].remove(ftl_rmv_)
    return routine, ov_crs_list, comp_list_, fn_time_list_

def copy_free_time_slots(routine, routine_copy):
    CalculateFreeTimeWeek(routine)
    for k, v in test_results.items():
        routine_copy[k] = []
        for i in range(len(v)):
            routine_copy[k].append(v[i])
    return routine_copy

# def find_alt_section(ov_crs_list, free_time_list):
#     rec_crs_ = {}
#     cnt_curr_, cnt_rec_ = {}, {}
#     curr_list_, cmp_list_ = [], []
#     count_exception_ = 0 
#     for key, value in base_routine.items():
#         for i in range(len(value)):
#             curr_day = value[i]
#             for j in range(len(curr_day)):
#                 # if course-slot is not empty
#                 if curr_day[j][0] != ():
#                     # take current course, time and sections
#                     curr_crs, curr_time, curr_sec = curr_day[j][0][0], curr_day[j][0][1], key
#                     # concatenate course and section as target
#                     curr_tar_ = curr_crs + ' ' + curr_sec
#                     # if target is not in current list
#                     if curr_tar_ not in curr_list_:
#                         # append it to current list and set CountBaseRoutine[target] = 1
#                         curr_list_.append(curr_tar_)
#                         cnt_curr_[curr_tar_] = 1
#                     else:
#                         # else increment CountBaseRoutine[target] by 1
#                         cnt_curr_[curr_tar_] += 1
#                     # for the post-appeared-courses
#                     for k in range(len(ov_crs_list)):
#                         # take that instance of overlapped_course and section
#                         ov_crs, ov_sec = ov_crs_list[k][0].split(' ')[0], ov_crs_list[k][0].split(' ')[1]
#                         # if current_course matches the overlapped_course and doesn't match overlapped_section
#                         if curr_crs == ov_crs and curr_sec != ov_sec:  
#                             # take the start & end times of that course             
#                             curr_st_, curr_end_ = int(''.join(curr_time.split('-')[0].split(':'))), int(''.join(curr_time.split('-')[1].split(':')))
#                             # for all the days of free-time-slots
#                             for v in range(len(free_time_list.values())):
#                                 # for each day's available time chunks
#                                 for b in range(len(list(free_time_list.values())[v])):
#                                     # if free-time-slot's day matches base__routine's day 
#                                     if v == i:
#                                         # that that instance of free-time-slot's start & end time
#                                         free_time_st_ = int(list(free_time_list.values())[v][b][0])
#                                         free_time_end_ = int(list(free_time_list.values())[v][b][1]) 
#                                         # if StartTime(current_course) and EndTime(current_course) is within
#                                         # StartTime(free_slot) and EndTime(free_slot)                                
#                                         if curr_st_ >= free_time_st_ and curr_end_ <= free_time_end_:
#                                             # target is now that course & section
#                                             curr_tar_ = curr_crs + ' ' + curr_sec
#                                             # if target is not in comparison_list
#                                             if curr_tar_ not in cmp_list_:
#                                                 # append it and set CountRecommend[target] = 1
#                                                 cmp_list_.append(curr_tar_)
#                                                 cnt_rec_[curr_tar_] = 1
#                                             # else increment CountRecommend[target] by 1
#                                             else:
#                                                 cnt_rec_[curr_tar_] += 1 
#                                             continue 
#                                         ### NEW ELEMENT ###
#                                         else:
#                                             if count_exception_ < 1:
#                                                 if curr_st_ >= (free_time_st_ - 30) and curr_end_ <= free_time_end_:
#                                                     curr_tar_ = curr_crs + ' ' + curr_sec
#                                                     if curr_tar_ not in cmp_list_:
#                                                         cmp_list_.append(curr_tar_)
#                                                         if len(cnt_rec_) <= 0:
#                                                             cnt_rec_[curr_tar_] = 1
#                                                         else:
#                                                             cnt_rec_[curr_tar_] += 1
#                                                     count_exception_ = 1
#                                                 elif curr_st_ >= free_time_st_ and curr_end_ <= (free_time_end_ + 30):
#                                                     curr_tar_ = curr_crs + ' ' + curr_sec
#                                                     if curr_tar_ not in cmp_list_:
#                                                         cmp_list_.append(curr_tar_)
#                                                         if len(cnt_rec_) <= 0:
#                                                             cnt_rec_[curr_tar_] = 1
#                                                         else:
#                                                             cnt_rec_[curr_tar_] += 1
#                                                     count_exception_ = 1
#     '''
#     identifying recommended courses
#     '''                                                
#     # For each courses in CountRecommend[course] and their counts
#     for k, v in cnt_rec_.items():
#         # if CountRecommend[course] matches CountBaseRoutine[course]
#         if cnt_rec_[k] == cnt_curr_[k]:
#             # mark that course as Recommended
#             rec_crs_[k] = True                                                
#     return rec_crs_, cnt_curr_, cnt_rec_, curr_list_, cmp_list_, count_exception_

def find_alt_section(ov_crs_list, free_time_list):
    rec_crs_ = {}
    curr_list_, cmp_list_ = [], []
    exception_list = []
    for key, value in base_routine.items():
        for i in range(len(value)): # track of day
            
            curr_day = value[i]
            for j in range(len(curr_day)):
                if curr_day[j][0] != ():
                    curr_crs, curr_time, curr_sec = curr_day[j][0][0], curr_day[j][0][1], key
                    curr_st_, curr_end_ = int(''.join(curr_time.split('-')[0].split(':'))), int(''.join(curr_time.split('-')[1].split(':')))
                    curr_tar_ = curr_crs + ' ' + curr_sec
                    curr_list_.append(curr_tar_)
                    for OCs in range(len(ov_crs_list)):
                        for oc in ov_crs_list[OCs]:
                            ov_crs, ov_sec = oc.split(' ')[0], oc.split(' ')[1]                        
                            if curr_crs == ov_crs and curr_sec != ov_sec:
                                for d, Ts in free_time_list.items():                               
                                    for t in range(len(Ts)):
                                        if free_time_list[d][t] != None:
                                            free_time_st_, free_time_end_ = int(free_time_list[d][t][0]), int(free_time_list[d][t][1])
                                            if d == i:
                                                if curr_st_ >= free_time_st_ and curr_end_ <= free_time_end_:
                                                    curr_tar_ = curr_crs + ' ' + curr_sec
                                                    cmp_list_.append(curr_tar_)
                                                    # print('1st if:', curr_tar_)
                                                    if curr_st_ == free_time_st_ and curr_end_ == free_time_end_:
                                                        # print('Perfect fit:', d, curr_tar_, free_time_list[d][t])
                                                        free_time_list[d].remove(free_time_list[d][t])
                                                    else:
                                                        # print('Loose fit:', d, curr_crs, curr_sec, curr_st_, curr_end_, curr_tar_, free_time_list[d][t], [curr_end_, free_time_end_])
                                                        if curr_st_ > free_time_st_ and curr_end_ == free_time_end_:
                                                            # free_time_list[d][t] = all_list.append([free_time_st_, curr_st_])
                                                            free_time_list[d][t] = [free_time_st_, curr_st_]
                                                            # print([free_time_st_, curr_st_])
                                                        elif curr_st_ > free_time_st_ and curr_end_ < free_time_end_:                                  
                                                            free_time_list[d][t] = [free_time_st_, curr_st_]
                                                            free_time_list[d].append([curr_end_, free_time_end_])
                                                            # print([free_time_st_, curr_st_])
                                                            # print([curr_end_, free_time_end_])
                                                            # print(free_time_list[d])
                                                    break
                                                else:
                                                    if len(exception_list) <= 0:
                                                        if curr_st_ >= (free_time_st_ - 30) and curr_end_ <= free_time_end_:
                                                            curr_tar_ = curr_crs + ' ' + curr_sec
                                                            cmp_list_.append(curr_tar_)
                                                            exception_list.append(curr_tar_)
                                                            if curr_end_ == free_time_end_:
                                                                free_time_list[d].remove(free_time_list[d][t])                                              
                                                            else:
                                                                free_time_list[d][t] = [curr_end_, free_time_end_]     
                                                            break
                                                        elif curr_st_ >= free_time_st_ and curr_end_ <= (free_time_end_ + 30):
                                                            curr_tar_ = curr_crs + ' ' + curr_sec
                                                            cmp_list_.append(curr_tar_)
                                                            exception_list.append(curr_tar_)
                                                            if curr_st_ == free_time_st_:
                                                                free_time_list[d].remove(free_time_list[d][t])      
                                                            else:
                                                                free_time_list[d][t] = [free_time_st_, curr_st_]
                                                            break
    '''
    identifying recommended courses
    '''
                                                    
    # For each courses in CountRecommend[course] and their counts
    for Cs in cmp_list_:
        fn_cnt = 0
        #print(Cs)
        if cmp_list_.count(Cs) == curr_list_.count(Cs):
            rec_crs_[Cs] = True       
            #print(Cs, list(rec_crs_.keys())) 
        recs_list = list(rec_crs_.keys())
        for w in range(len(recs_list)):
            if Cs.split(' ')[0] in recs_list[w].split(' ')[0]:
                fn_cnt += 1    
        if fn_cnt > 1:
            del rec_crs_[Cs]                                    
    return rec_crs_, curr_list_, cmp_list_, exception_list

def append_alt_crs(rec__crs__, routine, ftl):
    '''
    appending recommended-courses to the routine
    '''
    # For every courses marked as Recommended
    for k in rec__crs__.keys():
        # take that instance of course and section 
        ap_crs_, ap_sec_ = k.split(' ')[0], k.split(' ')[1]
        # for each section and days in base__routine__
        for sec, val in base_routine.items():
            # for every course in each day
            for v in range(len(val)):
                # if course-slot is not empty and recommended course's section matches base__routine's section
                if not val[v][0][0] == () and ap_sec_ == sec:
                    # for each course in every day
                    for c in range(len(val[v])):
                        # take current instance of base__routine's course and time
                        br_crs_, br_time_ = val[v][c][0][0], val[v][c][0][1]
                        # split the time into start and end time
                        br_st_, br_end_ = int(''.join(br_time_.split('-')[0].split(':'))), int(''.join(br_time_.split('-')[1].split(':')))
                        # if recommended course matches base__routine's course
                        if ap_crs_ == br_crs_:
                            # whichever day matches append that course to model's final_routine's day and sort the values 
                            if v == 0:
                                # print([f'{br_crs_} {sec}' , br_time_], routine['Sat'], [f'{br_crs_} {sec}' , br_time_] not in routine['Sat'])
                                if [f'{br_crs_} {sec}' , br_time_] not in routine['Sat']:
                                    routine['Sat'].append([f'{br_crs_} {sec}' , br_time_])
                                    ftl['Sat'].append([br_st_, br_time_]) 
                                    R_sort(ftl['Sat']) 
                            if v == 1:
                                # print([f'{br_crs_} {sec}' , br_time_], routine['Sun'], [f'{br_crs_} {sec}' , br_time_] not in routine['Sun'])
                                if [f'{br_crs_} {sec}' , br_time_] not in routine['Sun']:
                                    routine['Sun'].append([f'{br_crs_} {sec}' , br_time_])
                                    ftl['Sun'].append([br_st_, br_time_])  
                                    R_sort(ftl['Sun']) 
                            if v == 2:
                                # print([f'{br_crs_} {sec}' , br_time_], routine['Mon'], [f'{br_crs_} {sec}' , br_time_] not in routine['Mon'])
                                if [f'{br_crs_} {sec}' , br_time_] not in routine['Mon']:
                                    routine['Mon'].append([f'{br_crs_} {sec}' , br_time_])
                                    ftl['Mon'].append([br_st_, br_time_])  
                                    R_sort(ftl['Mon']) 
                            if v == 3:
                                # print([f'{br_crs_} {sec}' , br_time_], routine['Tue'], [f'{br_crs_} {sec}' , br_time_] not in routine['Tue'])
                                if [f'{br_crs_} {sec}' , br_time_] not in routine['Tue']:
                                    routine['Tue'].append([f'{br_crs_} {sec}' , br_time_])
                                    ftl['Tue'].append([br_st_, br_time_])  
                                    R_sort(ftl['Tue']) 
                            if v == 4:
                                # print([f'{br_crs_} {sec}' , br_time_], routine['Wed'], [f'{br_crs_} {sec}' , br_time_] not in routine['Wed'])
                                if [f'{br_crs_} {sec}' , br_time_] not in routine['Wed']:                                
                                    routine['Wed'].append([f'{br_crs_} {sec}' , br_time_])
                                    ftl['Wed'].append([br_st_, br_time_])  
                                    R_sort(ftl['Wed']) 
    '''
    Converting time to human-readable format
    we did this before as well, nothing new..
    '''
    for day, time in routine.items():
        for time_steps in range(len(time)):
            current_course, current_time = routine[day][time_steps][0], int(''.join(routine[day][time_steps][1].split('-')[0].split(':')))
            routine[day][time_steps][1] = current_time
        Sort(routine[day])

    for day, time in routine.items():
        for time_steps in range(len(time)):
            proper_time = ftl[day][time_steps][1]
            routine[day][time_steps][1] = proper_time

    return routine, ftl

def print_out(routine, dr):
    for day, courses in routine.items():
        for i in range(len(courses)):
            if routine[day][i][0] + ' ' + routine[day][i][1] not in dr[day]:
                dr[day].append(routine[day][i][0] +
                                ' ' + routine[day][i][1])
        print(day, *dr[day])

"""# Recommendation__System__"""

# @title Anvil GUI

# ! pip3 install anvil-uplink
import anvil.server

# anvil.server.connect("BXTNSNYRACX3BJ7TR7536LXV-KVOQB6A2U6UCKI5D")
anvil.server.connect("server_P7MKQDTZXWFQ5LDPKJSHHUJI-VCA3RIYMG7DSECB3")


@anvil.server.callable
def get_all_courses():
    sem_list = list(base_routine.keys())
    all_courses = []
    for i in range(8):
        sem = i+1
        all_courses.append(sem)
        # print(sem)
        if f"{sem}A" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}A"])):
                for time_steps in range(len(base_routine[f"{sem}A"][days])):
                    if not base_routine[f"{sem}A"][days][0][0] == ():
                        current_course = base_routine[f"{sem}A"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " A")
                            all_courses.append(f'{current_course} {sem}A')
        if f"{sem}A1" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}A1"])):
                for time_steps in range(len(base_routine[f"{sem}A1"][days])):
                    if not base_routine[f"{sem}A1"][days][0][0] == ():
                        current_course = base_routine[f"{sem}A1"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " A1")
                            all_courses.append(f'{current_course} {sem}A1')
        if f"{sem}A2" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}A2"])):
                for time_steps in range(len(base_routine[f"{sem}A2"][days])):
                    if not base_routine[f"{sem}A2"][days][0][0] == ():
                        current_course = base_routine[f"{sem}A2"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " A2")
                            all_courses.append(f'{current_course} {sem}A2')
        if f"{sem}B" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}B"])):
                for time_steps in range(len(base_routine[f"{sem}B"][days])):
                    if not base_routine[f"{sem}B"][days][0][0] == ():
                        current_course = base_routine[f"{sem}B"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " B")
                            all_courses.append(f'{current_course} {sem}B')
        if f"{sem}B1" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}B1"])):
                for time_steps in range(len(base_routine[f"{sem}B1"][days])):
                    if not base_routine[f"{sem}B1"][days][0][0] == ():
                        current_course = base_routine[f"{sem}B1"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " B1")
                            all_courses.append(f'{current_course} {sem}B1')
        if f"{sem}B2" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}B2"])):
                for time_steps in range(len(base_routine[f"{sem}B2"][days])):
                    if not base_routine[f"{sem}B2"][days][0][0] == ():
                        current_course = base_routine[f"{sem}B2"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " B2")
                            all_courses.append(f'{current_course} {sem}B2')
        if f"{sem}C" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}C"])):
                for time_steps in range(len(base_routine[f"{sem}C"][days])):
                    if not base_routine[f"{sem}C"][days][0][0] == ():
                        current_course = base_routine[f"{sem}C"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " C")
                            all_courses.append(f'{current_course} {sem}C')
        if f"{sem}C1" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}C1"])):
                for time_steps in range(len(base_routine[f"{sem}C1"][days])):
                    if not base_routine[f"{sem}C1"][days][0][0] == ():
                        current_course = base_routine[f"{sem}C1"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " C1")
                            all_courses.append(f'{current_course} {sem}C1')
        if f"{sem}C2" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}C2"])):
                for time_steps in range(len(base_routine[f"{sem}C2"][days])):
                    if not base_routine[f"{sem}C2"][days][0][0] == ():
                        current_course = base_routine[f"{sem}C2"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " C2")
                            all_courses.append(f'{current_course} {sem}C2')
        if f"{sem}D" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}D"])):
                for time_steps in range(len(base_routine[f"{sem}D"][days])):
                    if not base_routine[f"{sem}D"][days][0][0] == ():
                        current_course = base_routine[f"{sem}D"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " D")
                            all_courses.append(f'{current_course} {sem}D')
        if f"{sem}D1" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}D1"])):
                for time_steps in range(len(base_routine[f"{sem}D1"][days])):
                    if not base_routine[f"{sem}D1"][days][0][0] == ():
                        current_course = base_routine[f"{sem}D1"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " D1")
                            all_courses.append(f'{current_course} {sem}D1')
        if f"{sem}D2" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}D2"])):
                for time_steps in range(len(base_routine[f"{sem}D2"][days])):
                    if not base_routine[f"{sem}D2"][days][0][0] == ():
                        current_course = base_routine[f"{sem}D2"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " D2")
                            all_courses.append(f'{current_course} {sem}D2')
        if f"{sem}E" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}E"])):
                for time_steps in range(len(base_routine[f"{sem}E"][days])):
                    if not base_routine[f"{sem}E"][days][0][0] == ():
                        current_course = base_routine[f"{sem}E"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            # print(current_course, " E")
                            all_courses.append(f'{current_course} {sem}E')
    return all_courses


@anvil.server.callable
def generate_default_routine(user_choice):
    sections, courses = [], []
    dj_day, dj_course = [], []
    for items in user_choice:
        courses.append(items.split(' ')[0])
        sections.append(items.split(' ')[1])

    # final_routine, dummy_routine, final_time_list, comparison_list, overlap_list, overlap_days, overlapped_courses_1, overlapped_courses_2

    '''
    Creating blueprints
    '''
    final_routine = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    dummy_routine = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    final_time_list = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    comparison_list = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    overlap_list = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    overlap_days = {
        'Sat': False,
        'Sun': False,
        'Mon': False,
        'Tue': False,
        'Wed': False,
    }
    dj_msg = {
        'Sat': '',
        'Sun': '',
        'Mon': '',
        'Tue': '',
        'Wed': '',
    }
    '''
    Appending the courses while sorting them
    '''
    for section in range(len(sections)):
        for day in range(len(base_routine[sections[section]])):
            for course in range(len(base_routine[sections[section]][day])):
                if not base_routine[sections[section]][day][0][0] == ():
                    if courses[section] == base_routine[sections[section]][day][course][0][0]:
                        course_times = base_routine[sections[section]
                                                    ][day][course][0][1]
                        start_times = int(
                            "".join(course_times.split('-')[0].split(':')))
                        end_times = int(
                            "".join(course_times.split('-')[1].split(':')))
                        if day == 0:
                            final_routine['Sat'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Sat'])
                            dummy_routine['Sat'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Sat'])
                            final_time_list['Sat'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Sat'])
                            comparison_list['Sat'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Sat'])
                        elif day == 1:
                            final_routine['Sun'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Sun'])
                            dummy_routine['Sun'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Sun'])
                            final_time_list['Sun'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Sun'])
                            comparison_list['Sun'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Sun'])
                        elif day == 2:
                            final_routine['Mon'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Mon'])
                            dummy_routine['Mon'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Mon'])
                            final_time_list['Mon'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Mon'])
                            comparison_list['Mon'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Mon'])
                        elif day == 3:
                            final_routine['Tue'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Tue'])
                            dummy_routine['Tue'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Tue'])
                            final_time_list['Tue'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Tue'])
                            comparison_list['Tue'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Tue'])
                        elif day == 4:
                            final_routine['Wed'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Wed'])
                            dummy_routine['Wed'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Wed'])
                            final_time_list['Wed'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Wed'])
                            comparison_list['Wed'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Wed'])
    '''
    Converting course times back to their human readable format
    '''
    for day, info in final_routine.items():
        for readable_info in range(len(info)):
            final_routine[day][readable_info][1] = final_time_list[day][readable_info][1]
    '''
    Finally, checking for overlaps & printing the routine
    '''
    # print('\n\n\n\n\n')
    # print('Routine:')
    overlapped_courses_1 = []
    overlapped_courses_2 = []
    for day, time in comparison_list.items():
        for time_steps in range(len(time)):
            current_course = final_routine[day][time_steps][0]
            start_time, end_time = time[time_steps][0], time[time_steps][1]
            current_start_o, current_end_o = final_time_list[day][time_steps][1].split(
                '-')[0], final_time_list[day][time_steps][1].split('-')[1]
            if (time_steps > 0):
                for iterations in range(time_steps-1, -1, -1):
                    comparing_course = final_routine[day][iterations][0]
                    compare_start, compare_end = time[iterations][0], time[iterations][1]
                    compare_start_o, compare_end_o = final_time_list[day][iterations][1].split(
                        '-')[0], final_time_list[day][iterations][1].split('-')[1]
                    if compare_start <= start_time < compare_end:  # overlap detection
                        # print(f"{comparing_course}->{current_course}")
                        overlap_list[day].append([current_course, comparing_course, str(
                            CalculateOverlapTime(current_start_o, compare_end_o))])
                        if [comparing_course] not in overlapped_courses_1:
                            overlapped_courses_1.append([comparing_course])
                        if [current_course] not in overlapped_courses_2:
                            overlapped_courses_2.append(
                                [current_course])  # NEW !!
                        overlap_days[day] = True
            dummy_routine[day][time_steps] = final_routine[day][time_steps][0] + \
                ' ' + final_routine[day][time_steps][1]
        if overlap_days[day] == False:
            # print(f'{day}:', *dummy_routine[day])
            dj_day.append(day)
            dj_course.append(dummy_routine[day])
        else:
            for i in range(len(overlap_list[day])):
                # overlap_list[day][i] = overlap_list[day][i][0] + ',' + \
                #     overlap_list[day][i][1] + ' with ' + \
                #     overlap_list[day][i][2] + ' minutes'
                overlap_list[day][i] = overlap_list[day][i][0] + ',' + \
                    overlap_list[day][i][1] + ' ' + \
                    overlap_list[day][i][2] + ' minutes'
            err_msg = overlap_list[day]
            dj_msg[day] = err_msg
            dj_day.append(day)
            dj_course.append(dummy_routine[day])
    return dj_day, dj_course, dj_msg, final_routine, comparison_list, final_time_list, overlapped_courses_1, overlapped_courses_2


@anvil.server.callable
def create_structures(fr, cl, ftl):
    '''
    creating blueprints to store the 'main-routine', 'comparison-list', 'final-time-list' & test-results to cross-check both ends of overlap
    '''
    # trial_routine_1, trial_routine_2, comp_list_1, comp_list_2, comp_list_2, fn_time_l_1, fn_time_l_2, test_res_1, test_res_2, dr_1, dr_2
    trial_routine_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    trial_routine_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    comp_list_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    comp_list_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    fn_time_l_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    fn_time_l_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    test_res_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    test_res_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    dr_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    dr_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    '''
    copying values to the blueprints
    '''
    for k, v in fr.items():
        for i in range(len(v)):
            trial_routine_1[k].append(v[i])
            trial_routine_2[k].append(v[i])

    for k, v in cl.items():
        for i in range(len(v)):
            comp_list_1[k].append(v[i])
            comp_list_2[k].append(v[i])

    for k, v in ftl.items():
        for i in range(len(v)):
            fn_time_l_1[k].append(v[i])
            fn_time_l_2[k].append(v[i])

    return trial_routine_1, trial_routine_2, comp_list_1, comp_list_2, fn_time_l_1, fn_time_l_2, test_res_1, test_res_2, dr_1, dr_2


@anvil.server.callable
def generate_updated_routine(trout, oc, cl, ftl, tres):
    trout, oc, cl, ftl = rem__ov__crs(trout, oc, cl, ftl)
    tres = copy_free_time_slots(cl, tres)
    copy_tres = {}
    for i in range(5):
        copy_tres[i] = tres[list(tres.keys())[i]]
    rec_crs_, curr_list_, cmp_list_, exception_list = find_alt_section(
        oc, copy_tres)
    trout, ftl = append_alt_crs(rec_crs_, trout, ftl)
    return trout, tres, cl

anvil.server.wait_forever()