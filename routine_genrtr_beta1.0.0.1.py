# -*- coding: utf-8 -*-
"""routine_genRTR_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MOxB-55pSFCqRKrIUTpfybIc-FQOu8UF
### find_alt_section & overlaps on generate_updated_routine fixed ###
New: Course selection menu has course count
# Default__System__
"""
# @title Setup__base__routine__: Database
import anvil.server
base_routine = {
    "1A": [[[("CFE", "8:30-11:30")], [("MED", "11:30-13:00")]],
           [[("GE", "11:30-13:00")], [("PF", "13:00-14:30")],
            [("IEEL", "14:30-17:30")]],
           [[("PF", "10:00-11:30")], [("IEE", "11:30-13:00")],
            [("DIC", "13:00-14:30")]],
           [[("FBL", "9:30-11:30")], [("DIC", "11:30-13:00")],
            [("GE", "13:00-14:30")]],
           [[("PFL", "8:30-11:30")], [("IEE", "11:30-13:00")]],
           ],
    "1B": [[[("IEE", "11:30-13:00")]],
           [[("CFE", "8:30-11:30")], [("PF", "11:30-13:00")],
            [("GE", "13:00-14:30")]],
           [[("DIC", "8:30-10:00")], [("PF", "10:00-11:30")]],
           [[("FBL", "11:30-13:30")]],
           [[("DIC", "8:30-10:00")], [("GE", "10:00-11:30")],
            [("IEE", "11:30-13:00")]],
           ],
    "1B1": [[[("MED", "8:30-10:00")]],
            [[(), ()]],
            [[("IEEL", "11:30-14:30")]],
            [[("PFL", "8:30-11:30")]],
            [[(), ()]],
            ],
    "1B2": [[[("MED", "10:00-11:30")]],
            [[(), ()]],
            [[("PFL", "11:30-14:30")]],
            [[("IEEL", "8:30-11:30")]],
            [[(), ()]],
            ],
    "2A": [[[("FBL", "9:30-11:30")], [("DM", "11:30-13:00")]],
           [[("CPL", "8:30-10:00")], [("DM", "10:00-11:30")],
            [("EDC", "11:30-13:00")], [("PHYL", "13:00-16:00")]],
           [[("DSL", "8:30-11:30")], [("DS", "13:00-14:30")]],
           [[("EE", "11:30-13:00")], [("DS", "13:00-14:30")]],
           [[("EDCL", "8:30-11:30")], [("EE", "11:30-13:00")],
            [("EDC", "13:00-14:30")]],
           ],
    "2B": [[[("CPL", "8:30-10:00")], [("EDCL", "11:30-14:30")]],
           [[("EDC", "10:00-11:30")], [("DSL", "11:30-14:30")],
            [("FBL", "15:30-17:30")]],
           [[("DS", "11:30-13:00")], [("DM", "13:00-14:30")]],
           [[("PHYL", "10:00-13:00")], [("EE", "13:00-14:30")]],
           [[("DM", "10:00-11:30")], [("DS", "11:30-13:00")],
            [("EE", "13:00-14:30")]],
           ],
    "2C": [[[("EE", "8:30-10:00")], [("DM", "10:00-11:30")], [("DSL", "11:30-14:30")], [("DS", "16:00-17:30")]],
           [[("CPL", "10:00-11:30")], [("EDC", "11:30-13:00")],
            [("DM", "13:00-14:30")]],
           [[("EE", "8:30-10:00")], [("PHYL", "11:30-14:30")],
            [("EDCL", "14:30-17:30")]],
           [[("EDC", "13:00-14:30")], [("FBL", "15:30-17:30")]],
           [[("DS", "10:00-11:30")], [("EDC", "11:30-13:00")]],
           ],
    "2D": [[[("EDC", "8:30-10:00")], [("EE", "10:00-11:30")], [("DM", "13:00-14:30")], [("DS", "14:30-16:00")]],
           [[("EDC", "10:00-11:30")], [("DM", "11:30-13:00")],
            [("FBL", "13:30-15:30")]],
           [[("CPL", "8:30-10:00")], [("EE", "10:00-11:30")]],
           [[("DSL", "8:30-11:30")], [("EDCL", "11:30-14:30")]],
           [[("DS", "8:30-10:00")], [("PHYL", "11:30-14:30")]],
           ],

    "3A": [[[("OOP", "10:00-11:30")], [("DE", "13:00-14:30")]],
           [[("BE", "10:00-11:30")], [("DEL", "11:30-14:30")]],
           [[("EM-3", "11:30-13:00")], [("DS", "13:00-14:30")],
            [("DSL", "14:30-17:30")]],
           [[("EM-3", "8:30-10:00")], [("BE", "10:00-11:30")],
            [("OOPL", "11:30-14:30")]],
           [[("OOP", "10:00-11:30")], [("DS", "13:00-14:30")],
            [("DE", "14:30-16:00")]],
           ],
    "3B": [[[("DS", "8:30-10:00")], [("DE", "11:30-13:00")], [("EM-3", "13:00-14:30")]],
           [[("DS", "13:00-14:30")], [("OOPL", "14:30-17:30")]],
           [[("OOP", "8:30-10:00")], [("BE", "10:00-11:30")],
            [("DSL", "11:30-14:30")]],
           [[("OOP", "8:30-10:00")], [("EM-3", "11:30-13:00")]],
           [[("OOP", "8:30-10:00")], [("BE", "10:00-11:30")],
            [("DEL", "11:30-14:30")], [("DE", "16:00-17:30")]],
           ],
    "3C": [[[("DE", "10:00-11:30")], [("DS", "13:00-14:30")], [("DSL", "14:30-17:30")]],
           [[("DE", "8:30-10:00")], [("BE", "11:30-13:00")],
            [("EM-3", "13:00-14:30")]],
           [[("OOP", "10:00-11:30")], [("DS", "11:30-13:00")],
            [("EM-3", "13:00-14:30")]],
           [[("DEL", "14:30-17:30")]],
           [[("OOPL", "11:30-14:30")], [("BE", "14:30-16:00")]],
           ],

    "4A": [[[("IBM", "10:00-11:30")], [("SS", "11:30-13:00")], [("DMS", "13:00-14:30")], [("SSL", "14:30-16:30")]],
           [[(), ()]],
           [[("IBM", "10:00-11:30")], [("DMS", "13:00-14:30")],
            [("ADAL", "14:30-16:30")]],
           [[("ADA", "11:30-13:00")], [("EM-4", "13:00-14:30")],
            [("SS", "16:00-17:30")]],
           [[("EM-4", "11:30-13:00")], [("ADA", "13:00-14:30")],
            [("DMSL", "14:30-17:30")]],
           ],
    "4B": [[[("SS", "10:00-11:30")], [("IBM", "11:30-13:00")], [("DMSL", "14:30-17:30")]],
           [[("SSL", "9:30-11:30")], [("IBM", "11:30-13:00")],
            [("EM-4", "14:30-16:00")]],
           [[("DMS", "10:00-11:30")], [("ADA", "13:00-14:30")]],
           [[("DMS", "10:00-11:30")], [("ADAL", "13:00-15:00")]],
           [[("ADA", "11:30-13:00")], [("EM-4", "13:00-14:30")],
            [("SS", "16:00-17:30")]],
           ],
    "4C": [[[("ADAL", "9:30-11:30")], [("EM-4", "13:00-14:30")]],
           [[("EM-4", "8:30-10:00")], [("IBM", "10:00-11:30")],
            [("SS", "11:30-13:00")], [("DMS", "13:00-14:30")]],
           [[("IBM", "11:30-13:00")], [("DMS", "13:00-14:30")]],
           [[("ADA", "11:30-13:00")], [("SS", "13:00-14:30")],
            [("DMSL", "14:30-17:30")]],
           [[("ADA", "10:00-11:30")], [("SSL", "11:30-13:30")]],
           ],
    "4D": [[[("SS", "10:00-11:30")], [("IBM", "11:30-13:00")], [("ADAL", "14:30-16:30")]],
           [[("ADA", "8:30-10:00")], [("EM-4", "11:30-13:00")],
            [("DMSL", "14:30-17:30")]],
           [[("IBM", "10:00-11:30")], [("ADA", "11:30-13:00")],
            [("SS", "16:00-17:30")]],
           [[("SSL", "9:30-11:30")], [("DMS", "13:00-14:30")]],
           [[("EM-4", "10:00-11:30")], [("DMS", "11:30-13:00")]],
           ],
    "4E": [[[("SSL", "9:30-11:30")], [("SS", "11:30-13:00")], [("DMS", "13:00-14:30")]],
           [[("ADA", "8:30-10:00")], [("IBM", "10:00-11:30")]],
           [[("ADAL", "9:30-11:30")], [("IBM", "11:30-13:00")],
            [("SS", "14:30-16:00")]],
           [[("DMS", "10:00-11:30")], [("EM-4", "13:00-14:30")]],
           [[("DMSL", "8:30-11:30")], [("EM-4", "13:00-14:30")]],
           ],

    "5A": [[[("OB", "10:00-11:30")], [("CMEP", "11:30-13:00")]],
           [[("OB", "11:30-13:00")], [("MM", "13:00-14:30")]],
           [[("CMEP", "11:30-13:00")]],
           [[("CE", "8:30-10:00")], [("MM", "11:30-13:00")],
            [("SEISD", "13:00-14:30")]],
           [[("CE", "11:30-13:00")], [("SEISD", "13:00-14:30")]],
           ],
    "5A1": [[[(), ()]],
            [[("CMEPL", "10:00-11:30")]],
            [[("CEL", "8:30-11:30")], [("SEISDL", "14:30-17:30")]],
            [[(), ()]],
            [[("MML", "8:30-11:30")]],
            ],
    "5A2": [[[(), ()]],
            [[("SEISDL", "14:30-17:30")]],
            [[("MML", "8:30-11:30")], [("CEL", "14:30-17:30")]],
            [[("CMEPL", "10:00-11:30")]],
            [[(), ()]],
            ],

    "6A": [[[("CN", "11:30-13:00")], [("COA", "13:00-14:30")], [("AI", "14:30-16:00")]],
           [[("CN", "10:00-11:30")], [("SD", "11:30-14:30")]],
           [[("COA", "10:00-11:30")], [("CNL", "11:30-14:30")],
            [("AIL", "14:30-17:30")]],
           [[("AI", "8:30-10:00")], [("OS", "10:00-11:30")],
            [("OSL", "11:30-14:30")], [("DC", "16:00-17:30")]],
           [[("OS", "10:00-11:30")], [("AI", "13:00-14:30")],
            [("DC", "14:30-16:00")]],
           ],
    "6B": [[[("OS", "11:30-13:00")], [("COA", "13:00-14:30")]],
           [[("OS", "10:00-11:30")], [("OSL", "11:30-14:30")],
            [("AIL", "14:30-17:30")]],
           [[("CN", "10:00-11:30")], [("AI", "11:30-13:00")]],
           [[("CN", "10:00-11:30")], [("SD", "11:30-14:30")],
            [("DC", "14:30-16:00")]],
           [[("COA", "10:00-11:30")], [("CNL", "11:30-14:30")],
            [("DC", "16:00-17:30")]],
           ],

    "7A": [[[("TWP", "8:30-10:30")], [("TC", "10:30-12:30")]],
           [[("CSL", "8:30-11:30")], [("CS", "11:30-13:00")],
            [("NCS", "13:00-14:30")]],
           [[("CS", "10:00-11:30")], [("NNFL", "11:30-13:00")],
            [("NCS", "13:00-14:30")]],
           [[(), ()]],
           [[("CGIPL", "8:30-10:00")], [("NNFLL", "10:00-11:30")],
            [("NNFL", "13:00-14:30")]],
           ],
    "7B": [[[("TWP", "10:30-12:30")], [("NCS", "13:00-14:30")]],
           [[("TC", "9:30-11:30")], [("CGIP", "13:00-14:30")]],
           [[("CS", "8:30-10:00")], [("NNFL", "10:00-11:30")],
            [("CSL", "11:30-14:30")]],
           [[("CS", "10:00-11:30")], [("CGIP", "13:00-14:30")]],
           [[("NNFLL", "8:30-10:00")], [("CGIPL", "10:00-11:30")],
            [("NNFL", "11:30-13:00")], [("NCS", "13:00-14:30")]],
           ],
    "7C": [[[("CS", "10:00-11:30")], [("TWP", "12:30-14:30")], [("CSL", "14:30-17:30")]],
           [[("CGIPL", "8:30-10:00")], [("NNFLL", "10:00-11:30")],
            [("NNFL", "11:30-13:00")]],
           [[("NCS", "11:30-13:00")], [("CGIP", "13:00-14:30")]],
           [[("TC", "9:30-11:30")], [("CGIP", "11:30-13:00")]],
           [[("NNFL", "10:00-11:30")], [("NCS", "11:30-13:00")], [("CS", "16:00-17:30")]],
           ],
    "7D": [[[("CSL", "8:30-11:30")], [("CS", "11:30-13:00")], [("NCS", "13:00-14:30")]],
           [[("NNFLL", "8:30-10:00")], [("CGIPL", "10:00-11:30")],
            [("NCS", "11:30-13:00")]],
           [[("NNFL", "8:30-10:00")], [("CGIP", "11:30-13:00")]],
           [[("CGIP", "10:00-11:30")], [("TC", "11:30-13:30")]],
           [[("TWP", "8:30-10:30")], [("NNFL", "11:30-13:00")],
            [("CS", "14:30-16:00")]],
           ],
    "8A": [[[("PR", "11:30-13:00")], [("CCC", "13:00-14:30")]],
           [[("ML", "10:00-11:30")]],
           [[("PR", "8:30-10:00")], [("CC", "10:00-11:30")]],
           [[("CC", "10:00-11:30")], [("ML", "12:00-13:30")]],
           [[("PR", "11:30-13:00")], [("CCC", "13:00-14:30")]],
           ],
    "8A1": [[[(), ()]],
            [[("CCL", "11:30-14:30")]],
            [[("MLL", "11:30-13:00")], [("CCCL", "13:00-14:30")]],
            [[("PRL", "8:30-10:00")]],
            [[(), ()]],
            ],
    "8A2": [[[("CCCL", "10:00-11:30")]],
            [[("MLL", "11:30-13:00")], [("PRL", "13:00-14:30")]],
            [[("CCL", "11:30-14:30")]],
            [[(), ()]],
            [[(), ()]],
            ],
    "8B": [[[("PR", "10:00-11:30")]],
           [[("ML", "8:30-10:00")], [("CC", "11:30-13:00")]],
           [[("CCC", "11:30-13:00")]],
           [[("ML", "10:00-11:30")], [("CC", "11:30-13:00")]],
           [[("PR", "8:30-10:00")], [("CCC", "10:00-11:30")]],
           ],
    "8B1": [[[("MLL", "11:30-13:00")], [("PRL", "13:00-14:30")]],
            [[(), ()]],
            [[("CCCL", "10:00-11:30")]],
            [[(), ()]],
            [[("CCL", "11:30-14:30")]],
            ],
    "8B2": [[[("CCL", "11:30-14:30")]],
            [[("MLL", "10:00-11:30")]],
            [[(), ()]],
            [[(), ()]],
            [[("CCCL", "11:30-13:00")], [("PRL", "13:00-14:30")]],
            ],
    "8C": [[[("PR", "13:00-14:30")]],
           [[("CC", "8:30-10:00")], [("CCC", "11:30-13:00")]],
           [[("CCC", "10:00-11:30")], [("CC", "13:00-14:30")]],
           [[("ML", "8:30-10:00")]],
           [[("PR", "10:00-11:30")], [("ML", "11:30-13:00")]],
           ],
    "8C1": [[[("MLL", "14:30-16:00")], [("PRL", "16:00-17:30")]],
            [[(), ()]],
            [[(), ()]],
            [[("CCCL", "10:00-11:30")], [("CCL", "11:30-13:00")]],
            [[(), ()]],
            ],
    "8C2": [[[("CCL", "14:30-17:30")]],
            [[(), ()]],
            [[(), ()]],
            [[("MLL", "11:30-13:00")], [("CCCL", "13:00-14:30")]],
            [[("PRL", "14:30-16:00")]],
            ],
}

# @title Functions
'''
functions to sort courses using time_steps
'''


def Sort(sub_li):
    sub_li.sort(key=lambda x: x[1])
    return sub_li


def R_sort(sub_li):
    sub_li.sort(key=lambda x: x[0])
    return sub_li


'''
Function that counts overlap time
'''


def CalculateOverlapTime(t1, t2):
    hour1, minute1 = int(t1.split(':')[0]), int(t1.split(':')[1])
    hour2, minute2 = int(t2.split(':')[0]), int(t2.split(':')[1])
    min1, min2, min3 = 0, 0, 0
    for hrs in range(hour1, hour2+1):
        for mins in range(0, 60):
            if hour1 == hour2 and minute1 == minute2:
                minutes = 0
            elif mins >= minute1 and hrs == hour1:
                min1 += 1
            elif hour1 < hrs < hour2:
                min2 += 1
            elif mins < minute2 and hrs == hour2:
                min3 += 1
    minutes = min1 + min2 + min3
    return (minutes)


'''
Function to calculate available time-slots of a day
'''


def CalculateFreeTimeDay(l):
    time_range = []
    start_val, end_val = 830, 1730
    start_time, end_time = start_val, end_val
    # [i such that i belongs to length of courses] i.e 0->1->2->.. etc..
    for i in range(len(l)):
        course_start, course_end = l[i][0], l[i][1]
        # for all classes except for the last class
        if not course_end == end_val and i < len(l) - 1:
            # if that course has no-free-time before
            if course_start == start_time:
                start_time = course_end
            # if that course has free-time before
            elif course_start > start_time:
                checkpoint1, checkpoint2 = start_time, course_start
                time_range.append([checkpoint1, checkpoint2])
                start_time = course_end
            # handling duplicates
            elif i > 0 and course_start <= l[i-1][0] or course_end <= l[i-1][1]:
                start_time = l[i-1][1]
        # for last class or only class
        elif i == len(l) - 1:
            # if that course has no-free-time before & doesn't end at 17:30
            if course_start == start_time and course_end != end_time:
                checkpoint1, checkpoint2 = course_end, end_time
                time_range.append([checkpoint1, checkpoint2])
            # if that course has free-time before
            elif course_start > start_time:
                checkpoint1, checkpoint2 = start_time, course_start
                time_range.append([checkpoint1, checkpoint2])
                # & doesn't end at 17:30
                if course_end != end_time:
                    checkpoint3, checkpoint4 = course_end, end_time
                    time_range.append([checkpoint3, checkpoint4])
            # handling duplicates
            elif i > 0 and course_start <= l[i-1][0] or course_end <= l[i-1][1]:
                checkpoint1, checkpoint2 = l[i-1][1], end_time
                time_range.append([checkpoint1, checkpoint2])
            elif start_time > course_start and course_end != end_time:
                checkpoint1, checkpoint2 = course_end, end_time
                time_range.append([checkpoint1, checkpoint2])
    R_sort(time_range)
    return (time_range)


'''
extending that to calculate free-time-slots of the whole week
'''
test_results = {
    'Sat': [],
    'Sun': [],
    'Mon': [],
    'Tue': [],
    'Wed': []
}


def CalculateFreeTimeWeek(week):
    for day, times in week.items():
        test_results[day] = CalculateFreeTimeDay(times)
        # print(f'{day}:', test_results[day])
# Removing overlapped courses


def rem__ov__crs(routine, ov_crs_list, comp_list_, fn_time_list_):
    for day, val in routine.items():
        removing_crs_ = []
        for i in range(len(val)):
            curr_slot_, curr_crs_ = val[i], val[i][0]
            for j in range(len(ov_crs_list)):
                if curr_crs_ == ov_crs_list[j][0]:
                    removing_crs_.append(curr_slot_)
        for slots in removing_crs_:
            for k in range(len(routine[day])):
                if routine[day][k] == slots:
                    fr_rmv_ = routine[day][k]
                    cl_rmv_ = comp_list_[day][k]
                    ftl_rmv_ = fn_time_list_[day][k]
            routine[day].remove(fr_rmv_)
            comp_list_[day].remove(cl_rmv_)
            fn_time_list_[day].remove(ftl_rmv_)
    return routine, ov_crs_list, comp_list_, fn_time_list_
# Getting free-time-slots


def copy_free_time_slots(routine, routine_copy):
    CalculateFreeTimeWeek(routine)
    for k, v in test_results.items():
        routine_copy[k] = []
        for i in range(len(v)):
            routine_copy[k].append(v[i])
    return routine_copy
# Finding alternate sections


def find_alt_section(ov_crs_list, free_time_list):
    rec_crs_ = {}
    curr_list_, cmp_list_ = [], []
    exception_list = []
    course_sections = {}  # Maintain a dictionary of course names and their sections
    for key, value in base_routine.items():
        for i in range(len(value)):  # track of day
            curr_day = value[i]
            for j in range(len(curr_day)):
                if curr_day[j][0] != ():
                    curr_crs, curr_time, curr_sec = curr_day[j][0][0], curr_day[j][0][1], key
                    curr_st_, curr_end_ = int(''.join(curr_time.split(
                        '-')[0].split(':'))), int(''.join(curr_time.split('-')[1].split(':')))
                    curr_tar_ = curr_crs + ' ' + curr_sec

                    # Check if the same course's other section is already present
                    if curr_crs in course_sections:
                        if curr_sec in course_sections[curr_crs]:
                            continue

                    # Add the course-section pair to the current list and dictionary
                    curr_list_.append(curr_tar_)
                    if curr_crs not in course_sections:
                        course_sections[curr_crs] = set()
                    course_sections[curr_crs].add(curr_sec)

                    for OCs in range(len(ov_crs_list)):
                        for oc in ov_crs_list[OCs]:
                            ov_crs, ov_sec = oc.split(' ')[0], oc.split(' ')[1]
                            if curr_crs == ov_crs and curr_sec != ov_sec:
                                for d, Ts in free_time_list.items():
                                    for t in range(len(Ts)):
                                        if free_time_list[d][t] != None:
                                            free_time_st_, free_time_end_ = int(
                                                free_time_list[d][t][0]), int(free_time_list[d][t][1])
                                            if d == i:
                                                if curr_st_ >= free_time_st_ and curr_end_ <= free_time_end_:
                                                    curr_tar_ = curr_crs + ' ' + curr_sec
                                                    cmp_list_.append(curr_tar_)
                                                    if curr_st_ == free_time_st_ and curr_end_ == free_time_end_:
                                                        # print('Perfect fit:', d, curr_tar_, free_time_list[d][t])
                                                        free_time_list[d].remove(
                                                            free_time_list[d][t])
                                                    else:
                                                        # print('Loose fit:', d, curr_crs, curr_sec, curr_st_, curr_end_, curr_tar_, free_time_list[d][t], [curr_end_, free_time_end_])
                                                        if curr_st_ > free_time_st_ and curr_end_ == free_time_end_:
                                                            free_time_list[d][t] = [
                                                                free_time_st_, curr_st_]
                                                        elif curr_st_ > free_time_st_ and curr_end_ < free_time_end_:
                                                            free_time_list[d][t] = [
                                                                free_time_st_, curr_st_]
                                                            free_time_list[d].append(
                                                                [curr_end_, free_time_end_])
                                                    break
                                                # else:
                                                #     if len(exception_list) <= 0:
                                                #         if curr_st_ >= (free_time_st_ - 30) and curr_end_ <= free_time_end_:
                                                #             curr_tar_ = curr_crs + ' ' + curr_sec
                                                #             cmp_list_.append(
                                                #                 curr_tar_)
                                                #             exception_list.append(
                                                #                 curr_tar_)
                                                #             if curr_end_ == free_time_end_:
                                                #                 free_time_list[d].remove(
                                                #                     free_time_list[d][t])
                                                #             else:
                                                #                 free_time_list[d][t] = [
                                                #                     curr_end_, free_time_end_]
                                                #             break
                                                #         elif curr_st_ >= free_time_st_ and curr_end_ <= (free_time_end_ + 30):
                                                #             curr_tar_ = curr_crs + ' ' + curr_sec
                                                #             cmp_list_.append(
                                                #                 curr_tar_)
                                                #             exception_list.append(
                                                #                 curr_tar_)
                                                #             if curr_st_ == free_time_st_:
                                                #                 free_time_list[d].remove(
                                                #                     free_time_list[d][t])
                                                #             else:
                                                #                 free_time_list[d][t] = [
                                                #                     free_time_st_, curr_st_]
                                                #             break
    '''
    identifying recommended courses
    '''
    # For each courses in CountRecommend[course] and their counts
    for Cs in cmp_list_:
        fn_cnt = 0
        print(Cs, cmp_list_.count(Cs), curr_list_.count(Cs))
        if cmp_list_.count(Cs) == curr_list_.count(Cs):
            rec_crs_[Cs] = True
        recs_list = list(rec_crs_.keys())
        for w in range(len(recs_list)):
            print("w.. ", w)
            if Cs.split(' ')[0] in recs_list[w].split(' ')[0]:
                fn_cnt += 1
        if fn_cnt > 1:
            del rec_crs_[Cs]
            # print(Cs, rec_crs_[Cs])
    return rec_crs_, curr_list_, cmp_list_, exception_list
# Adding updated courses


def append_alt_crs(rec__crs__, routine, ftl):
    '''
    appending recommended-courses to the routine
    '''
    # For every courses marked as Recommended
    for k in rec__crs__.keys():
        # take that instance of course and section
        ap_crs_, ap_sec_ = k.split(' ')[0], k.split(' ')[1]
        # for each section and days in base__routine__
        for sec, val in base_routine.items():
            # for every course in each day
            for v in range(len(val)):
                # if course-slot is not empty and recommended course's section matches base__routine's section
                if not val[v][0][0] == () and ap_sec_ == sec:
                    # for each course in every day
                    for c in range(len(val[v])):
                        # take current instance of base__routine's course and time
                        br_crs_, br_time_ = val[v][c][0][0], val[v][c][0][1]
                        # split the time into start and end time
                        br_st_, br_end_ = int(''.join(br_time_.split(
                            '-')[0].split(':'))), int(''.join(br_time_.split('-')[1].split(':')))
                        # if recommended course matches base__routine's course
                        if ap_crs_ == br_crs_:
                            # whichever day matches append that course to model's final_routine's day and sort the values
                            if v == 0:
                                # Check if the new course overlaps with any existing courses in this day
                                overlaps = False
                                for existing_course in routine['Sat']:
                                    existing_time = existing_course[1]
                                    existing_st, existing_end = int(''.join(existing_time.split('-')[0].split(':'))), int(
                                        ''.join(existing_time.split('-')[1].split(':')))
                                    if br_end_ > existing_st and existing_end > br_st_:
                                        overlaps = True
                                        break
                                if not overlaps:
                                    routine['Sat'].append(
                                        [f'{br_crs_} {sec}', br_time_])
                                    ftl['Sat'].append([br_st_, br_time_])
                                    R_sort(ftl['Sat'])
                            if v == 1:
                                # Check if the new course overlaps with any existing courses in this day
                                overlaps = False
                                for existing_course in routine['Sun']:
                                    existing_time = existing_course[1]
                                    existing_st, existing_end = int(''.join(existing_time.split('-')[0].split(':'))), int(
                                        ''.join(existing_time.split('-')[1].split(':')))
                                    if br_end_ > existing_st and existing_end > br_st_:
                                        overlaps = True
                                        break
                                if not overlaps:
                                    routine['Sun'].append(
                                        [f'{br_crs_} {sec}', br_time_])
                                    ftl['Sun'].append([br_st_, br_time_])
                                    R_sort(ftl['Sun'])
                            if v == 2:
                                # Check if the new course overlaps with any existing courses in this day
                                overlaps = False
                                for existing_course in routine['Mon']:
                                    existing_time = existing_course[1]
                                    existing_st, existing_end = int(''.join(existing_time.split('-')[0].split(':'))), int(
                                        ''.join(existing_time.split('-')[1].split(':')))
                                    if br_end_ > existing_st and existing_end > br_st_:
                                        overlaps = True
                                        break
                                if not overlaps:
                                    routine['Mon'].append(
                                        [f'{br_crs_} {sec}', br_time_])
                                    ftl['Mon'].append([br_st_, br_time_])
                                    R_sort(ftl['Mon'])
                            if v == 3:
                                # Check if the new course overlaps with any existing courses in this day
                                overlaps = False
                                for existing_course in routine['Tue']:
                                    existing_time = existing_course[1]
                                    existing_st, existing_end = int(''.join(existing_time.split('-')[0].split(':'))), int(
                                        ''.join(existing_time.split('-')[1].split(':')))
                                    if br_end_ > existing_st and existing_end > br_st_:
                                        overlaps = True
                                        break
                                if not overlaps:
                                    routine['Tue'].append(
                                        [f'{br_crs_} {sec}', br_time_])
                                    ftl['Tue'].append([br_st_, br_time_])
                                    R_sort(ftl['Tue'])
                            if v == 4:
                                # Check if the new course overlaps with any existing courses in this day
                                overlaps = False
                                for existing_course in routine['Wed']:
                                    existing_time = existing_course[1]
                                    existing_st, existing_end = int(''.join(existing_time.split('-')[0].split(':'))), int(
                                        ''.join(existing_time.split('-')[1].split(':')))
                                    if br_end_ > existing_st and existing_end > br_st_:
                                        overlaps = True
                                        break
                                if not overlaps:
                                    routine['Wed'].append(
                                        [f'{br_crs_} {sec}', br_time_])
                                    ftl['Wed'].append([br_st_, br_time_])
                                    R_sort(ftl['Wed'])
    '''
    Converting time to human-readable format
    '''
    for day, time in routine.items():
        for time_steps in range(len(time)):
            current_course, current_time = routine[day][time_steps][0], int(
                ''.join(routine[day][time_steps][1].split('-')[0].split(':')))
            routine[day][time_steps][1] = current_time
        Sort(routine[day])

    for day, time in routine.items():
        for time_steps in range(len(time)):
            proper_time = ftl[day][time_steps][1]
            routine[day][time_steps][1] = proper_time

    return routine, ftl
# Creting a printout of the dummy-routine


def print_out(routine, dr):
    for day, courses in routine.items():
        for i in range(len(courses)):
            if routine[day][i][0] + ' ' + routine[day][i][1] not in dr[day]:
                dr[day].append(routine[day][i][0] +
                               ' ' + routine[day][i][1])
        print(day, *dr[day])


"""# Recommendation__System__"""

# @title Anvil GUI

# ! pip3 install anvil-uplink

# anvil.server.connect("BXTNSNYRACX3BJ7TR7536LXV-KVOQB6A2U6UCKI5D")
anvil.server.connect("server_P7MKQDTZXWFQ5LDPKJSHHUJI-VCA3RIYMG7DSECB3")

# Sending list of all courses to client-side


@anvil.server.callable
def get_all_courses():
    sem_list = list(base_routine.keys())
    all_courses = []
    for i in range(8):
        sem = i+1
        all_courses.append(sem)
        if f"{sem}A" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}A"])):
                for time_steps in range(len(base_routine[f"{sem}A"][days])):
                    if not base_routine[f"{sem}A"][days][0][0] == ():
                        current_course = base_routine[f"{sem}A"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}A')
        if f"{sem}A1" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}A1"])):
                for time_steps in range(len(base_routine[f"{sem}A1"][days])):
                    if not base_routine[f"{sem}A1"][days][0][0] == ():
                        current_course = base_routine[f"{sem}A1"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}A1')
        if f"{sem}A2" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}A2"])):
                for time_steps in range(len(base_routine[f"{sem}A2"][days])):
                    if not base_routine[f"{sem}A2"][days][0][0] == ():
                        current_course = base_routine[f"{sem}A2"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}A2')
        if f"{sem}B" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}B"])):
                for time_steps in range(len(base_routine[f"{sem}B"][days])):
                    if not base_routine[f"{sem}B"][days][0][0] == ():
                        current_course = base_routine[f"{sem}B"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}B')
        if f"{sem}B1" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}B1"])):
                for time_steps in range(len(base_routine[f"{sem}B1"][days])):
                    if not base_routine[f"{sem}B1"][days][0][0] == ():
                        current_course = base_routine[f"{sem}B1"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}B1')
        if f"{sem}B2" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}B2"])):
                for time_steps in range(len(base_routine[f"{sem}B2"][days])):
                    if not base_routine[f"{sem}B2"][days][0][0] == ():
                        current_course = base_routine[f"{sem}B2"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}B2')
        if f"{sem}C" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}C"])):
                for time_steps in range(len(base_routine[f"{sem}C"][days])):
                    if not base_routine[f"{sem}C"][days][0][0] == ():
                        current_course = base_routine[f"{sem}C"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}C')
        if f"{sem}C1" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}C1"])):
                for time_steps in range(len(base_routine[f"{sem}C1"][days])):
                    if not base_routine[f"{sem}C1"][days][0][0] == ():
                        current_course = base_routine[f"{sem}C1"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}C1')
        if f"{sem}C2" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}C2"])):
                for time_steps in range(len(base_routine[f"{sem}C2"][days])):
                    if not base_routine[f"{sem}C2"][days][0][0] == ():
                        current_course = base_routine[f"{sem}C2"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}C2')
        if f"{sem}D" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}D"])):
                for time_steps in range(len(base_routine[f"{sem}D"][days])):
                    if not base_routine[f"{sem}D"][days][0][0] == ():
                        current_course = base_routine[f"{sem}D"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}D')
        if f"{sem}D1" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}D1"])):
                for time_steps in range(len(base_routine[f"{sem}D1"][days])):
                    if not base_routine[f"{sem}D1"][days][0][0] == ():
                        current_course = base_routine[f"{sem}D1"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}D1')
        if f"{sem}D2" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}D2"])):
                for time_steps in range(len(base_routine[f"{sem}D2"][days])):
                    if not base_routine[f"{sem}D2"][days][0][0] == ():
                        current_course = base_routine[f"{sem}D2"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}D2')
        if f"{sem}E" in sem_list:
            visited = []
            for days in range(len(base_routine[f"{sem}E"])):
                for time_steps in range(len(base_routine[f"{sem}E"][days])):
                    if not base_routine[f"{sem}E"][days][0][0] == ():
                        current_course = base_routine[f"{sem}E"][days][time_steps][0][0]
                        if current_course not in visited and not current_course == ():
                            visited.append(current_course)
                            all_courses.append(f'{current_course} {sem}E')
    return all_courses

# Generating default routine


@anvil.server.callable
def generate_default_routine(user_choice):
    sections, courses = [], []
    dj_day, dj_course = [], []
    for items in user_choice:
        courses.append(items.split(' ')[0])
        sections.append(items.split(' ')[1])
    '''
    Creating blueprints
    '''
    final_routine = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    dummy_routine = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    final_time_list = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    comparison_list = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    overlap_list = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    overlap_days = {
        'Sat': False,
        'Sun': False,
        'Mon': False,
        'Tue': False,
        'Wed': False,
    }
    dj_msg = {
        'Sat': '',
        'Sun': '',
        'Mon': '',
        'Tue': '',
        'Wed': '',
    }
    '''
    Appending the courses while sorting them
    '''
    for section in range(len(sections)):
        for day in range(len(base_routine[sections[section]])):
            for course in range(len(base_routine[sections[section]][day])):
                if not base_routine[sections[section]][day][0][0] == ():
                    if courses[section] == base_routine[sections[section]][day][course][0][0]:
                        course_times = base_routine[sections[section]
                                                    ][day][course][0][1]
                        start_times = int(
                            "".join(course_times.split('-')[0].split(':')))
                        end_times = int(
                            "".join(course_times.split('-')[1].split(':')))
                        if day == 0:
                            final_routine['Sat'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Sat'])
                            dummy_routine['Sat'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Sat'])
                            final_time_list['Sat'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Sat'])
                            comparison_list['Sat'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Sat'])
                        elif day == 1:
                            final_routine['Sun'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Sun'])
                            dummy_routine['Sun'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Sun'])
                            final_time_list['Sun'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Sun'])
                            comparison_list['Sun'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Sun'])
                        elif day == 2:
                            final_routine['Mon'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Mon'])
                            dummy_routine['Mon'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Mon'])
                            final_time_list['Mon'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Mon'])
                            comparison_list['Mon'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Mon'])
                        elif day == 3:
                            final_routine['Tue'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Tue'])
                            dummy_routine['Tue'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Tue'])
                            final_time_list['Tue'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Tue'])
                            comparison_list['Tue'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Tue'])
                        elif day == 4:
                            final_routine['Wed'].append(
                                [f'{courses[section]} {sections[section]}', start_times])
                            Sort(final_routine['Wed'])
                            dummy_routine['Wed'].append(
                                [courses[section], start_times])
                            Sort(dummy_routine['Wed'])
                            final_time_list['Wed'].append(
                                [start_times, course_times])
                            R_sort(final_time_list['Wed'])
                            comparison_list['Wed'].append(
                                [start_times, end_times])
                            R_sort(comparison_list['Wed'])
    '''
    Converting course times back to their human readable format
    we did this before as well, nothing new..
    '''
    for day, info in final_routine.items():
        for readable_info in range(len(info)):
            final_routine[day][readable_info][1] = final_time_list[day][readable_info][1]
    '''
    Finally, checking for overlaps & printing the routine
    '''
    overlapped_courses_1 = []
    overlapped_courses_2 = []
    for day, time in comparison_list.items():
        for time_steps in range(len(time)):
            current_course = final_routine[day][time_steps][0]
            start_time, end_time = time[time_steps][0], time[time_steps][1]
            current_start_o, current_end_o = final_time_list[day][time_steps][1].split(
                '-')[0], final_time_list[day][time_steps][1].split('-')[1]
            if (time_steps > 0):
                for iterations in range(time_steps-1, -1, -1):
                    comparing_course = final_routine[day][iterations][0]
                    compare_start, compare_end = time[iterations][0], time[iterations][1]
                    compare_start_o, compare_end_o = final_time_list[day][iterations][1].split(
                        '-')[0], final_time_list[day][iterations][1].split('-')[1]
                    if compare_start <= start_time < compare_end:  # overlap detection
                        overlap_list[day].append([current_course, comparing_course, str(
                            CalculateOverlapTime(current_start_o, compare_end_o))])
                        if [comparing_course] not in overlapped_courses_1:
                            overlapped_courses_1.append([comparing_course])
                        if [current_course] not in overlapped_courses_2:
                            overlapped_courses_2.append(
                                [current_course])  # NEW !!
                        overlap_days[day] = True
            dummy_routine[day][time_steps] = final_routine[day][time_steps][0] + \
                ' ' + final_routine[day][time_steps][1]
        if overlap_days[day] == False:
            dj_day.append(day)
            dj_course.append(dummy_routine[day])
        else:
            for i in range(len(overlap_list[day])):
                overlap_list[day][i] = overlap_list[day][i][0] + ',' + \
                    overlap_list[day][i][1] + ' ' + \
                    overlap_list[day][i][2] + ' minutes'
            err_msg = overlap_list[day]
            dj_msg[day] = err_msg
            dj_day.append(day)
            dj_course.append(dummy_routine[day])
    return dj_day, dj_course, dj_msg, final_routine, comparison_list, final_time_list, overlapped_courses_1, overlapped_courses_2

# Creating structures for calculation


@anvil.server.callable
def create_structures(fr, cl, ftl):
    '''
    creating blueprints to store the 'main-routine', 'comparison-list', 'final-time-list' & test-results to cross-check both ends of overlap
    '''
    # trial_routine_1, trial_routine_2, comp_list_1, comp_list_2, comp_list_2, fn_time_l_1, fn_time_l_2, test_res_1, test_res_2, dr_1, dr_2
    trial_routine_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    trial_routine_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    comp_list_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    comp_list_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    fn_time_l_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    fn_time_l_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    test_res_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    test_res_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }

    dr_1 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    dr_2 = {
        'Sat': [],
        'Sun': [],
        'Mon': [],
        'Tue': [],
        'Wed': [],
    }
    '''
    copying values to the blueprints
    '''
    for k, v in fr.items():
        for i in range(len(v)):
            trial_routine_1[k].append(v[i])
            trial_routine_2[k].append(v[i])

    for k, v in cl.items():
        for i in range(len(v)):
            comp_list_1[k].append(v[i])
            comp_list_2[k].append(v[i])

    for k, v in ftl.items():
        for i in range(len(v)):
            fn_time_l_1[k].append(v[i])
            fn_time_l_2[k].append(v[i])

    return trial_routine_1, trial_routine_2, comp_list_1, comp_list_2, fn_time_l_1, fn_time_l_2, test_res_1, test_res_2, dr_1, dr_2

# Generating updated routine (One for All)


@anvil.server.callable
def generate_updated_routine(trout, oc, cl, ftl, tres):
    trout, oc, cl, ftl = rem__ov__crs(trout, oc, cl, ftl)
    tres = copy_free_time_slots(cl, tres)
    copy_tres = {}
    for i in range(5):
        copy_tres[i] = tres[list(tres.keys())[i]]
    rec_crs_, curr_list_, cmp_list_, exception_list = find_alt_section(
        oc, copy_tres)
    trout, ftl = append_alt_crs(rec_crs_, trout, ftl)
    return trout, tres, cl


anvil.server.wait_forever()
